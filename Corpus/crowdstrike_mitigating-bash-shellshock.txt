Mitigating Bash ShellShock
Following the frenzy of patch releases in reaction to the CVE-2014-6271 Bash Vulnerability (ShellShock), several blogs and articles were published detailing the vulnerability, but there has been less discussion on the steps one can take to mitigate the threat.  This blog seeks to provide actionable information and recommendations for readers to proactively defend against ShellShock.
Overall, the vulnerability in and of itself does not allow remote execution, but rather the implementation of a vulnerable bash shell as a part of a network based service. We will first review why a vulnerable local shell is dangerous for remote execution. Second, we will identify specific steps to mitigate the risk within your network and illustrate a repeatable example of a web page that provides the avenue for remote execution.
Realistically, there are a lot of machines out there that need to be patched, and patching them all will take some time. Therefore, the information provided in these steps is aimed at helping improve the efficiency of this process and limiting the amount of exposure and damage that ShellShock may otherwise have on your network.
At the end of this blog, the Recommendations for Mitigation section highlights tools and techniques that administrators can use to protect their networks.
CVE-2014-6271 vulnerability is described by NIST as “Bash through 4.3 processes trailing strings after function definitions in the values of environment variables, which allows remote attackers to execute arbitrary code via a crafted environment”. This means any strings trailing a bash function will be executed, when the function and strings are stored in an environmental variable, and then passed to a spawned shell via the exporting of that variable. The “crafted environment” NIST mentions, refers to how the arbitrary code is executed and the requirement that variables storing the function be parsed by bash. When a new bash shell is spawned, it parses all environmental variables provided or passed to it.
In our example below, the export command ensures that the variable declared will be passed to any subsequent environments called by bash.

The example below shows how CVE-2014-6271 can be executed within a bash shell environment.
 In the above example, the “echo” command is executed upon the spawning of the new bash shell. By exporting a variable that contains a function “() { :; };” with a trailing command “echo …”, the desired arbitrary execution is achieved.
The configuration we’re using is an OSX 10.9.5 with PHP 5.4.30 running the web service. However your configuration and environment will vary. Note that this part of our set-up does not contain the vulnerability. The “-S” option binds our local loopback address on TCP port 8080 and the “-t” defines the local directory as the root directory of the webserver.
Our web server is hosting two files detailed in the sections below:
The web server looks for and executes “index.php” by default. Notice in this case that our page is executing the intended bash script, which will run an unpatched (vulnerable) version of bash. The vulnerable script, titled “bashcgi.sh”, is given the HTTP GET request variable named “mycmd” as the first argument upon script execution.
If you were to open a web browser to “http://127.0.0.1/index.php?mycmd=asdf”; the command line interpretation of this would be:$ ./bashcgi.sh asdf
As you’ll notice in the script code, the first argument (“$1”) does not even come anywhere near traditional execution. Variables stored in scripting are not typically used for execution unless directly referenced by the command interpreter. In this instance the first argument passed to the script is exported as the variable named “vardec” for variable declaration.
In the case of our previous example with the command “$./bashcgi.sh asdf”, the executed code within the script would look like: “export vardec=asdf”. Thus any subsequent environments would be able to make reference to the “vardec” variable.
To take advantage of this vulnerability from a local command line standpoint you can execute the script with the following argument:
The script will execute and run the arbitrary code. A new file will be created in the same directory called “my_touched_file”.
By leveraging a specially crafted HTTP GET request, we can use the variable passed to the script to take advantage of the vulnerability in bash.
http://127.0.0.1:8080/?mycmd=”() { :; }; <command here>”
The PHP page calls the bash script, and passes it the “mycmd” variable as the scripts first argument. The argument is then exported in the variable named “vardec”.
The variable “vardec” will now be passed to any subsequent environments (bash shells) that the script calls. At this point, the variable contains the string “() { :; }; <command here>”.
The vulnerability is executed upon when the bashcgi.sh script executes the following line: bash -c “echo <br>Bash Executed</br>”
The called bash shell parses the string trailing the function in the “vardec” variable and executes the code as a command.
As seen in our example, in order to achieve remote execution, specific conditions must be met. We start with a network service (HTTP) executing code (PHP), which passes un-sanitized data (PHP) to a bash environment (bash script). Inside the bash script, the un-sanitized variable must be exported, and a subsequent bash shell must be spawned in order for the arbitrary code to be parsed and executed.

At this point you may be thinking, “What’s the big deal? It takes a lot for remote execution to occur in this case.” The impact of this vulnerability goes well beyond web servers. An exported variable containing un-sanitized user input can exploit any network service that executes a child bash shell. This is entirely dependent on the interpreting services that handle user input. In the case of Apache’s mod_cgi and mod_cgid handlers, execution can be achieved if the script is written in bash or if the script calls a bash shell. The remote vulnerability is presented in the way user input is handled. With the right conditions, a malformed cookie may even contain data used to gain remote execution on a host web server. User content stored in a database may also be used in a script variable that could possibly lead to inadvertent execution.
Within 24 hours of the CVE disclosure, CrowdStrike observed multiple tactics to gain remote access to hosts, including attempted downloading and execution of Unix based RATs, netcat and /dev/tcp reverse shell commands, webshell uploads, and multiple PERL based IRC bots. It is imperative that network operators remain vigilant in the next couple of weeks while software developers provide patches to fix this far-reaching vulnerability.
Outside of telling everyone to patch, patch, and patch again; there are a few tasks that can be performed to help check for and mitigate possible attack vectors and detect successful attacks.


 
