VENOM Vulnerability Details
Recently, I discovered a vulnerability in QEMU‘s virtual Floppy Disk Controller (FDC), exploitation of which may allow malicious code inside a virtual machine guest to perform arbitrary code execution on the host machine (a “VM escape”).
Since then, my colleagues and I have worked closely with key impacted software vendors, major infrastructure service providers, and security appliance vendors to remediate the vulnerability prior to or immediately upon the May 13th, 2015 public disclosure and patch release.
With fixes now released and the impact of the vulnerability minimized through the industry’s patching practices, I wanted to follow up with the release of the full details of the critical-impact vulnerability VENOM (CVE-2015-3456) for a technical audience. All code snippets below are from http://git.qemu.org/?p=qemu.git;f=hw/block/fdc.c;hb=24a5c62cfe3cbe3fb4722f79661b9900a2579316, which was the latest version of QEMU’s FDC code before the VENOM vulnerability was publicly patched on 2015-05-13.
QEMU’s FDC uses a 512-byte first-in first-out (FIFO) buffer for data storage:
The FDC’s data_pos and data_len fields above are initialized to 0 upon FDC reset.
Code in the VM guest can write to the FIFO buffer by sending data to the FDC via its FD_REG_FIFO I/O port. Writes are handled by the function below, with each byte sent to the I/O port getting passed to this function as the value parameter:
The function above uses the first received I/O byte as a command ID, with each ID mapping to a handler:
Each handler has an associated parameter count (stored in the parameters variable) and the I/O bytes written to the FIFO buffer after the command ID byte are considered parameters for the command handler. When fdctrl_write_data() determines that all parameters have been supplied (by comparing the incrementing data_pos with data_len), the command handler’s function is called to operate on the data in the FIFO buffer.
The FDC supports 32 different FIFO-based commands, including a default handler for unrecognized command ID values. The code path for each command handler function resets the FDC’s data_pos to 0 at the end of its processing, ensuring that the FIFO buffer can’t be overflowed. See below for an example, where the handler function fdctrl_handle_partid() calls fdctrl_set_fifo() which resets data_pos to 0:
For 30 of the command handler functions, this data_pos reset happens immediately at the completion of the command processing, similarly to the example above. However, for two of the command handler functions, the data_pos reset is delayed or can be circumvented.
The code below shows the handler for the “READ ID” command:
The fdctrl_handle_readid() function above sets a 20 ms timer (result_timer is initialized to point to the function fdctrl_result_timer() during FDC initialization). After 20 ms, fdctrl_result_timer() gets executed, which calls fdctrl_stop_transfer(), which calls fdctrl_set_fifo(), which resets data_pos to 0. During that 20 ms time window though, code in the VM guest can continue writing to the FIFO buffer, and since fdctrl_write_data() will continue to increment data_pos for each I/O byte received, code in the VM guest can overflow the FIFO buffer with arbitrary data.
The code below shows the handler for the “DRIVE SPECIFICATION COMMAND” command:
The fdctrl_handle_drive_specification_command() function above is called after the FDC receives the FD_CMD_DRIVE_SPECIFICATION_COMMAND command and its 5 parameter bytes. The if-condition in the handler will evaluate to false if the fifth parameter byte doesn’t have its most-significant-bit (MSB) set. The else-if-condition will always evaluate to false since fdctrl->data_len will always be set to 6 by the fdctrl_write_data() function for the FD_CMD_DRIVE_SPECIFICATION_COMMAND command. Thus, after sending the FD_CMD_DRIVE_SPECIFICATION_COMMAND command and its 5 parameter bytes (with the fifth parameter byte’s MSB set to 0), code in the VM guest can continue writing to the FIFO buffer, and since fdctrl_write_data() will continue to increment data_pos for each I/O byte received, code in the VM guest can overflow the FIFO buffer with arbitrary data.
